# QuikMultiBridge

Мост Lua<->Python для написания плагинов для терминала ARQA QUIK на Python. Зачем ещё? Ну, просто данная реализация соответствует моему представлению о прекрасном. Вот некоторые особенности, некоторые уже готовы, некоторые в работе:
- Написан на C++ с использованием библиотеки Qt
- Питон загружается через соответствующие C-шные интерфейсы, то есть интерпретатор становится частью QUIK
- Позволяет добавлять собственный интерфейс написанный на Qml/JS (пока не реализовано)
- Имеет встроенную консоль в которую выводится весь вывод из print (пока не реализовано)
- Подгружает Python-овскую venv
- !!! Собирается единажды, после чего не требует пересборки при изменениях АПИ, что достигается полностью динамическим разбором параметров и возвращаемых значений
- Позволяет писать как индикаторы, так и роботов

Завершение всей работы наверное ещё займет какое-то время, но в принципе сейчас уже всё работает. Есть проблемы с numpy - сам numpy неправильно выгружается, поэтому если скрипт использует его, то после остановки запустить его снова не удастся, нужно полностью перезапускать quik. Также сейчас в работе работа с DataSource - тут сложности скорее не технические, а организационные что-ли - надо найти какой-то красивый и прозрачный способ обёртывать DS в пайтоновские объекты причём не завязываясь на структуру DS (это главное чего я хотел добиться - ненужность перекомпиляции, использование просто dll, которая кладется в папку квика и затем там же пишется py скрипт)
## Как писать скрипт
1. Инициализация бриджа из lua
```lua
require "QuikMultiBridge"

bridgeConfig = {
    venvPath="c:\\Work\\QuikMultiBridge\\PythonQuik\\tstvenv",
    bridgeModule="qbridge",
    scriptPath="c:\\Work\\QuikMultiBridge\\PythonQuik\\pyRobo.py",
    eventLoopName="main"
    };

initBridge("Python", bridgeConfig);
```
Что здесь происходит:
- подключаем dll (можно переименовать её, но смысл?)
- готовим конфиг, в котором указываем путь к venv, имя модуля, как мы к нему будем обращаться из Python, путь к скрипту, lua метод, который будет у нас основным потоком (об этом ниже)
- инициализируем бридж указывая что нужно загрузить плагин Python (там заложено несколько вариантов включая R, Qt remote objects, Qt server, но пока есть только Python) и передаём ему конфиг.
2. Открываем документацию от ARQA "Интерпретатор Lua" и пишем скрипт на Python как если бы мы писали его на Lua с небольшими отличиями:
- main реализует сам бридж (имя мы указали в конфигурации), потому-что нам нужен этот цикл как диспетчер событий, где можно рисовать интерфейс, принимать события от системы и тд. Сам же eventLoop в бридже будет вызывать специальную функцию на каждом цикле из питона.
- для вызова методов quik мы используем метод бриджа invokeQuik

Но, лучше, давайте посмотрим пример скрипта Python:
```python
import ctypes
import qbridge
from datetime import datetime


OutputDebugString = ctypes.windll.kernel32.OutputDebugStringW
OutputDebugString("Test message from python")


def processBridgeEvents():
    OutputDebugString(datetime.now().strftime("%Y.%m.%d %H:%M:%S"))
    qbridge.invokeQuik("sleep", [1000])


def OnStop(flag):
    if flag == 1:
        OutputDebugString("Stopped from dialog")
    else:
        OutputDebugString("Stopped on exit")
    qbridge.quitBridge()
    return 10000


# Press the green button in the gutter to run the script.
if __name__ == '__main__':
    OutputDebugString("if __main__ block started")
    # qbridge.registerCallback('main', main)
    OutputDebugString("Hello from python!")
    qbridge.registerCallback('OnStop', OnStop)
    OutputDebugString("Callback registered")
    qbridge.registerProcessEventsCallback(processBridgeEvents)

```
import qbridge - тут мы импортируем модуль бриджа с именем, который мы ему задали в конфигурации

Дальше две строки с инициализацией метода OutputDebugString, который простая замена квикового PrintDbgStr (смысл дёргать квик если мы можем напрямую делать то же самое)

Метод processBridgeEvents по сути является единичным шагом цикла main, как вы бы его писали на lua. В нём мы выводим дату/время и вызываем sleep из квика при помощи invokeQuik. Таким способом мы не закладываемся на сигнатуру вызова, вместо этого разработчик сам смотрит что и как передавать по документации. Параметры всегда передаются как массив (list в терминах Python), даже если в массиве один элемент. То, что в lua называется таблицами передаётся как dict

Функция OnStop ничем не примечательна, кроме способа завершения скрипта вызовом quitBridge скрипта. Этот вызов завершает eventLoop и подчищает всё за собой

В блоке if (стандартная фишка Python, но в принципе можно и без if) мы делаем некоторую подготовительную работу:
- регистрируем колбэки (в данном случае один - OnStop)
- регистрируем специальный колбэк который вызывается из eventLoop - то есть шаг цикла main

То есть бридж предоставляет только 4 метода:
- registerCallback
- registerProcessEventsCallback
- invokeQuik
- quitBridge

По мере доработки буду дописывать док.


